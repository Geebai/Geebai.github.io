<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>既白</title>
  
  <subtitle>天才是什么样子的呢？</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-07T07:42:08.282Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>G1bai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreadLocal浅析</title>
    <link href="http://example.com/2022/04/10/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7ThreadLocal/"/>
    <id>http://example.com/2022/04/10/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7ThreadLocal/</id>
    <published>2022-04-10T13:45:24.000Z</published>
    <updated>2022-05-07T07:42:08.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal浅析"><a href="#ThreadLocal浅析" class="headerlink" title="ThreadLocal浅析"></a>ThreadLocal浅析</h1><h3 id="1-ThreadLocal是什么？"><a href="#1-ThreadLocal是什么？" class="headerlink" title="1. ThreadLocal是什么？"></a>1. ThreadLocal是什么？</h3><p>​    从名字我们就可以看到<code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p><p>​    从字面意思很容易理解，但是实际角度就没那么容易了，作为一个面试常问的点，使用场景也是很丰富。</p><ul><li>1、在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。</li><li>2、线程间数据隔离</li><li>3、进行事务操作，用于存储线程事务信息。</li><li>4、数据库连接，<code>Session</code>会话管理。</li></ul><h4 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h4><p>​    现在相信你已经对<code>ThreadLocal</code>有一个大致的认识了，下面我们看看如何用？</p><p>​    由于在项目中在MyMetaObjecthandler类中无法获取Session中的id，无法进行updateUser的设置，使用ThreadLocal类来进行变量的传递。</p><h6 id="步骤一-在common文件夹下创建基于Threadlocal封装工具类"><a href="#步骤一-在common文件夹下创建基于Threadlocal封装工具类" class="headerlink" title="步骤一 .在common文件夹下创建基于Threadlocal封装工具类"></a>步骤一 .在common文件夹下创建基于Threadlocal封装工具类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基于Threadlocal封装工具类，用于保存和获取当前用户id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; threadLocal =<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCurrentId</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        threadLocal.set(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getCurrentId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="步骤二-在LoginCheckFilter中设置id的值"><a href="#步骤二-在LoginCheckFilter中设置id的值" class="headerlink" title="步骤二.在LoginCheckFilter中设置id的值"></a>步骤二.在LoginCheckFilter中设置id的值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、判断登录状态，如果已登录，则直接放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户已登录，用户id为：&#123;&#125;&quot;</span>,request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>));</span><br><span class="line"></span><br><span class="line">            Long empId=(Long)request.getSession().getAttribute(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">            <span class="comment">//在过滤器中设置ID的值</span></span><br><span class="line">            BaseContext.setCurrentId(empId);</span><br><span class="line"></span><br><span class="line">            filterChain.doFilter(request,response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h6 id="步骤三-在MyMetaObjecthandler类中取出id的值"><a href="#步骤三-在MyMetaObjecthandler类中取出id的值" class="headerlink" title="步骤三.在MyMetaObjecthandler类中取出id的值"></a>步骤三.在MyMetaObjecthandler类中取出id的值</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjecthandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;公共字段自动填充insert&quot;</span>);</span><br><span class="line">      log.info(metaObject.toString());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">      metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充update&quot;</span>);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>ThreadLocal不是一个线程，二十Thread的局部变量。ThreadLocal为每个线程单独提供一份存储空间，线程外不能访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal浅析&quot;&gt;&lt;a href=&quot;#ThreadLocal浅析&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal浅析&quot;&gt;&lt;/a&gt;ThreadLocal浅析&lt;/h1&gt;&lt;h3 id=&quot;1-ThreadLocal是什么？&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>公共字段自动填充注解@TableField</title>
    <link href="http://example.com/2022/04/08/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E8%87%AA%E5%8A%A8%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85@TableField/"/>
    <id>http://example.com/2022/04/08/Java%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%E8%87%AA%E5%8A%A8%E5%AD%97%E6%AE%B5%E5%A1%AB%E5%85%85@TableField/</id>
    <published>2022-04-08T13:45:24.000Z</published>
    <updated>2022-05-07T09:17:04.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TableField的公共自动字段填充"><a href="#TableField的公共自动字段填充" class="headerlink" title="@TableField的公共自动字段填充"></a>@TableField的公共自动字段填充</h1><h2 id="一、使用场景"><a href="#一、使用场景" class="headerlink" title="一、使用场景"></a>一、使用场景</h2><p>​    在后台系统的员工管理功能的开发中，在新增员工时需要设置创建时间、创建人呢、修改时间等字段。在编辑员工时需要设置修改事件和修改人等字段。这些字段属于公共字段，也就是很多表中都有这些字段。这时候可以将这些公共字段在某个地方来统一处理来简化开发。使用Mybatis plus中的<u>公共字段填充</u>功能。</p><h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><ol><li><p>首先在实体类的属性上加入@TableField注解，指定自动填充的策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span><span class="comment">//插入时填充字段</span></span><br><span class="line">  <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">  <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><span class="comment">//插入和更新时填充字段</span></span><br><span class="line">  <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@TableField(fill = FieldFill.INSERT)</span><span class="comment">//插入时填充字段</span></span><br><span class="line">  <span class="keyword">private</span> Long createUser;</span><br><span class="line">   </span><br><span class="line">  <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><span class="comment">//插入和更新时填充字段</span></span><br><span class="line">  <span class="keyword">private</span> Long updateUser;</span><br></pre></td></tr></table></figure></li><li><p>按照框架要去编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现MetaObjectHandler接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMetaObjecthandler</span> <span class="keyword">implements</span> <span class="title">MetaObjectHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">&quot;公共字段自动填充insert&quot;</span>);</span><br><span class="line">      log.info(metaObject.toString());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">      metaObject.setValue(<span class="string">&quot;createUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">      metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFill</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;公共字段自动填充update&quot;</span>);</span><br><span class="line">        log.info(metaObject.toString());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now());</span><br><span class="line">        metaObject.setValue(<span class="string">&quot;updateUser&quot;</span>, BaseContext.getCurrentId());<span class="comment">//取出id的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TableField的公共自动字段填充&quot;&gt;&lt;a href=&quot;#TableField的公共自动字段填充&quot; class=&quot;headerlink&quot; title=&quot;@TableField的公共自动字段填充&quot;&gt;&lt;/a&gt;@TableField的公共自动字段填充&lt;/h1&gt;&lt;h2</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>测试基础</title>
    <link href="http://example.com/2021/08/18/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/08/18/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-18T12:29:53.000Z</published>
    <updated>2021-08-19T01:30:23.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h1><p>V模型</p><p>敏捷模型：</p><h3 id="1、按是否要运行程序进行划分"><a href="#1、按是否要运行程序进行划分" class="headerlink" title="1、按是否要运行程序进行划分"></a>1、按是否要运行程序进行划分</h3><p>  静态测试：是不运行被测试程序而寻找程序代码中可能存在的错误或评估程序代码的过程。（代码走查，桌面检查—看文档，软件界面设计）</p><p>  动态测试：运行被测试程序，输入相应的测试数据，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。</p><h3 id="2、按是否检查软件的代码程序；"><a href="#2、按是否检查软件的代码程序；" class="headerlink" title="2、按是否检查软件的代码程序；"></a>2、按是否检查软件的代码程序；</h3><p> 黑盒测试: 把软件程序当做一个黑色的盒子，不关心程序内部代码结构，只关心软件功能是否正常；(界面测试，功能测试，安装测试。。。。)</p><p>灰盒测试: 既要关心程序功能，也要查看程序代码实现；</p><p>白盒测试: 只关心程序的内部结构，不关心外部功能。白盒测试：写代码测试代码</p><h3 id="3、冒烟测试"><a href="#3、冒烟测试" class="headerlink" title="3、冒烟测试"></a>3、冒烟测试</h3><p>冒烟测试（Smoke testing）的对象是每一个新编译的需要正式测试的软件版本，目的是确认软件基本功能正常，可以进行后续的正式测试工作。</p><p>对象是每一个新编译：开发人员</p><p>软件基本功能：一般只考虑软件正向功能</p><h3 id="4、回归测试"><a href="#4、回归测试" class="headerlink" title="4、回归测试"></a>4、回归测试</h3><p>在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，对软件的任何新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再现。</p><p>1、验证开发修改好的bug是否正确解决；</p><p>2、验证跟该bug/功能有关联的模块是否引入了新的问题；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;测试基础&quot;&gt;&lt;a href=&quot;#测试基础&quot; class=&quot;headerlink&quot; title=&quot;测试基础&quot;&gt;&lt;/a&gt;测试基础&lt;/h1&gt;&lt;p&gt;V模型&lt;/p&gt;
&lt;p&gt;敏捷模型：&lt;/p&gt;
&lt;h3 id=&quot;1、按是否要运行程序进行划分&quot;&gt;&lt;a href=&quot;#1、按是否要运</summary>
      
    
    
    
    <category term="测试" scheme="http://example.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2021/08/10/Python/"/>
    <id>http://example.com/2021/08/10/Python/</id>
    <published>2021-08-10T13:45:24.000Z</published>
    <updated>2021-08-17T11:21:09.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python学习笔记"><a href="#Python学习笔记" class="headerlink" title="Python学习笔记"></a>Python学习笔记</h1><h2 id="1、Python标识符规则"><a href="#1、Python标识符规则" class="headerlink" title="1、Python标识符规则"></a>1、Python标识符规则</h2><ol><li>由字母、数字、下划线组成</li><li>不能以数字开头</li><li>不能以关键字作为标识符</li><li>标识符区分大小写</li></ol><h2 id="2、Python关键字"><a href="#2、Python关键字" class="headerlink" title="2、Python关键字"></a>2、Python关键字</h2><p>==and as assert break class continue def del elif else except exec finally for from global if in import is lambda not or pass print raise return try while with yield====</p><h2 id="3、标准数据类型"><a href="#3、标准数据类型" class="headerlink" title="3、标准数据类型"></a>3、标准数据类型</h2><ul><li><p>不可变类型: Number（数字）、String（字符串）Tuple（元组）、Sets（集合）</p></li><li><p>可变数据类型: List（列表）、Dictionary（字典）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>()  <span class="comment">#查看数据类型</span></span><br><span class="line"><span class="keyword">import</span> sys <span class="comment">#引入sys模块</span></span><br><span class="line">sys.getsizeof() <span class="comment">#查看字节数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1、Python数字类型"><a href="#1、Python数字类型" class="headerlink" title="1、Python数字类型"></a>1、Python数字类型</h3><ul><li><p>Int：整型，Python3整型是没有限制大小的，可以当作Long类型使用，所以Python3没有Python2的Long类型。举例1010055</p></li><li><p>Float：浮点型，用来表示带有小数部分的数据，比如10.5-33.3e10</p></li><li><p>Bool：布尔类型，用来表示逻辑真、逻辑假，只有两个值True或者False，在Python中它们的数值分别为1和0，可以跟其它数据类型的数据进行运算</p></li><li><p>Complex：复数类型，复数由实数部分和虚数部分构成，可以用a+bj,或者complex(a,b)表示，复数的实部a和虚部b都是浮点型比如4.5e-7j 3.14j</p></li></ul><h3 id="2、Python字符串类型"><a href="#2、Python字符串类型" class="headerlink" title="2、Python字符串类型"></a>2、Python字符串类型</h3><p>Python中的字符串用单引号 (‘ )或双引号(“ )括起来，同时使用反斜杠( \ )转义特殊字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;HelloWorld!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)<span class="comment">#输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])<span class="comment">#输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])<span class="comment">#输出字符串中第三个至第五个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])<span class="comment">#输出从第三个字符开始的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>*<span class="number">2</span>)<span class="comment">#输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>+<span class="string">&#x27;TEST&#x27;</span>)<span class="comment">#输出连接的字符串</span></span><br></pre></td></tr></table></figure><p>字符串常用方法举例:</p><ol><li>capitalize():将字符串第一个字符大写</li><li>lower()：将整个字符串都小写</li><li>upper()：将整个字符串都大写</li><li>replace(old,new,[count]): 将字符串中的old子串替换为new，替换count次，默认全部替换</li><li>split(sep)：将字符串用给定的标准分割，并且以列表形式返回分割后的元素组</li></ol><h3 id="3、Python列表-list-类型"><a href="#3、Python列表-list-类型" class="headerlink" title="3、Python列表(list)类型"></a>3、Python列表(list)类型</h3><ol><li>列表用[]标识，是python最通用的复合数据类型。</li><li>列表中值的分割也可以用到变量[头下标:尾下标]，就可以截取相应的列表，从左到右索引默认0开始的，从右到左索引默认-1开始，下标可以为空表示取到头或尾。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="string">&#x27;abcd&#x27;</span>,<span class="number">786</span>,<span class="number">2.23</span>,<span class="string">&#x27;john&#x27;</span>,<span class="number">70.2</span>]</span><br><span class="line">tinylist=[<span class="number">123</span>,<span class="string">&#x27;john&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)<span class="comment">#输出完整列表</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">0</span>])<span class="comment">#输出列表的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])<span class="comment">#输出第二个至第三个的元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>[<span class="number">2</span>:])<span class="comment">#输出从第三个开始至列表末尾的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tinylist*<span class="number">2</span>)<span class="comment">#输出列表两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>+tinylist)<span class="comment">#打印组合的列表</span></span><br></pre></td></tr></table></figure><p><strong>列表常用操作方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">L.append(var)<span class="comment">#追加元素</span></span><br><span class="line">L.insert(index,var)<span class="comment">#在指定位置插入元素</span></span><br><span class="line">L.pop(var)<span class="comment">#返回最后一个元素，并从list中删除之,也可以删除指定位置的元素</span></span><br><span class="line">L.remove(var)<span class="comment">#删除第一次出现的该元素</span></span><br><span class="line">L.count(var)<span class="comment">#该元素在列表中出现的个数</span></span><br><span class="line">L.index(var)<span class="comment">#该元素的位置,无则抛异常</span></span><br><span class="line">L.extend(<span class="built_in">list</span>)<span class="comment">#追加list，即合并list到L上</span></span><br><span class="line">L.sort()<span class="comment">#排序</span></span><br><span class="line">L.reverse()<span class="comment">#反转</span></span><br></pre></td></tr></table></figure><h3 id="4、Python元组-tuple-类型"><a href="#4、Python元组-tuple-类型" class="headerlink" title="4、Python元组(tuple)类型"></a>4、Python元组(tuple)类型</h3><p>元组是类似于List（列表）的另一个数据类型。</p><p>元组用()标识，内部元素用逗号隔开。但是元素不能二次赋值，相当于只读列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1=()<span class="comment">#空元组</span></span><br><span class="line">tup2=(<span class="number">20</span>,)<span class="comment">#一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>1、元组也可以被索引和切片，方法与列表一样；</li><li>2、与字符串一样，元组之间可以使用+号和*号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组；</li><li>3、元组可以使用之前列表中的count()、index()方法，其余的方法不行；</li><li>4、因为元组不可变，所以代码更安全。如果可能，能用元组代替列表就尽量用元组。</li></ul><h3 id="5、Python集合-set-类型"><a href="#5、Python集合-set-类型" class="headerlink" title="5、Python集合(set)类型"></a>5、Python集合(set)类型</h3><p>集合（set）是一个无序不重复元素的序列。基本功能是进行成员关系测试和删除重复元素。可以使用大括号{}或者set()函数创建集合，</p><p><strong>注意：创建一个空集合必须用set()而不是{}，因为{}是用来创建一个空字典</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">set</span>(<span class="string">&#x27;newdream66&#x27;</span>)</span><br><span class="line">b=<span class="built_in">set</span>(<span class="string">&#x27;news90&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a-b)<span class="comment">#a和b的差集即打印a中存在，但b中不存在的元素</span></span><br><span class="line"><span class="built_in">print</span>(b-a)<span class="comment">#b和a的差集即打印b中存在，但a中不存在的元素</span></span><br><span class="line"><span class="built_in">print</span>(b|a)<span class="comment">#a和b的并集即打印a和b中不重复的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(a&amp;b)<span class="comment">#a和b的交集即打印a和b中都存在的元素</span></span><br><span class="line"><span class="built_in">print</span>(a^b)<span class="comment">#a和b中不同时存在的元素</span></span><br></pre></td></tr></table></figure><p>#可以用in关键字判定元素是否在集合内。</p><h3 id="6、Python字典-Dictionary-类型"><a href="#6、Python字典-Dictionary-类型" class="headerlink" title="6、Python字典(Dictionary)类型"></a>6、Python字典(Dictionary)类型</h3><ul><li>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。</li><li>列表是有序的对象集合，字典是无序的对象集合。</li><li>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</li><li>字典用”{}”标识。字典由索引(key)和它对应的值value组成。字典也被称作关联数组或哈希表。</li></ul><p><strong>创建字典：</strong></p><p>简单地说字典就是用大括号包裹的键值对的集合（键值对也被称作项）</p><ol><li>一般形式：adict={}  adict={key1：value1，key2：value2，…}</li><li>使用工厂方法dict()创建字典：adict=dict()或adict=dict(([‘x’,1],[‘y’,2]))</li><li>关键字参数创建字典，如：adict=dict(name=’allen’,age=’40′)</li><li>使用内建方法fromkeys(S[,v]))，即将S里的元素作为键，v作为所有键的值，即字典中的元素具有相同的值，v的默认值为None。L1=[1,2,3]d.fromkeys(L1)dict.fromkeys(L1,’over’){1:’over’,2:’over’,3:’over’}b={}.fromkeys((‘x’,’y’),1)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adict[new_key]=value<span class="comment">#形式添加一个项</span></span><br><span class="line">adict[old_key]=new_value<span class="comment">#更新一个数据项（元素）或键值对</span></span><br><span class="line">deladict[key]<span class="comment">#删除键key的项/deladict删除整个字典</span></span><br></pre></td></tr></table></figure><p><strong>字典常用方法：</strong></p><ol><li>adict.keys()返回一个包含字典所有KEY的列表；</li><li>adict.values()返回一个包含字典所有value的列表；</li><li>adict.clear()删除字典中的所有项或元素；</li><li>adict.get(key,default=None)返回字典中key对应的值，若key不存在字典中，则返回default的值（default默认为None）；</li><li>adict.pop(key[,default])和get方法相似。如果字典中存在key，删除并返回key对应的vuale；如果key不存在，且没有给出default的值，则引发keyerror异常；</li><li>adict.update(bdict)将字典bdict的键值对添加到字典adict中，无则添加，有则覆盖</li></ol><h2 id="4、Python分支语句"><a href="#4、Python分支语句" class="headerlink" title="4、Python分支语句"></a>4、Python分支语句</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。可以通过右图来简单了解条件语句的执行过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1.</span>.....</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2.</span>.....</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">执行语句<span class="number">3.</span>.....</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">执行语句<span class="number">4.</span>.....</span><br></pre></td></tr></table></figure><h2 id="5、Python循环语句"><a href="#5、Python循环语句" class="headerlink" title="5、Python循环语句"></a>5、Python循环语句</h2><h3 id="1、While循环"><a href="#1、While循环" class="headerlink" title="1、While循环"></a>1、While循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line">执行语句......</span><br><span class="line">[<span class="keyword">else</span>:</span><br><span class="line">执行语句......]</span><br><span class="line"><span class="comment">#执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。当判断条件假false时，循环结束。else中的语句会在循环正常执行完</span></span><br></pre></td></tr></table></figure><h3 id="2、for循环"><a href="#2、for循环" class="headerlink" title="2、for循环"></a>2、for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">执行语句...</span><br><span class="line">[<span class="keyword">else</span>:</span><br><span class="line">执行语句...]</span><br><span class="line"><span class="comment">#每次循环,迭代变量被设置为可迭代对象(序列,迭代器,或者是其他支持迭代的对象)的当前元素,提供执行语句块使用，直到可迭代对象遍历完成终止。</span></span><br></pre></td></tr></table></figure><p>range()函数：</p><p>如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列。</p><p>range()语法：</p><ul><li>​                range(start,end,step=1):顾头不顾尾range(10):默认step＝1，start＝0,生成可迭代对象，包含[0,1,2,3,4,5,6,7,8,9]</li><li>​                range(1,10):指定start＝1，end＝10，默认step＝1，生成可迭代对象，包含[1,2,3,4,5,6,7,8,9]</li><li>​                range(1,10,2):指定start＝1，end＝10，step＝2，生成可迭代对象，包含[1,3,5,7,9]</li></ul><ol><li>break语句：用来终止循环语句，即循环条件没有False条件或者序列还没被完全递归完，也会停止执行循环语句。break语句用在while和for循环中。如果使用嵌套循环，break语句将停止执行最深层的循环，并开始执行下一行代码。</li><li>continue语句：用来告诉Python跳过当前循环的剩余语句，然后继续进行下一轮循环。continue语句用在while和for循环中。</li><li>pass语句：是空语句，是为了保持程序结构的完整性。pass不做任何事情，一般用做占位语句。</li></ol><h2 id="6、Python函数"><a href="#6、Python函数" class="headerlink" title="6、Python函数"></a>6、Python函数</h2><p>函数概念：函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性和代码的重复利用率，可以被用户调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_var_args</span>(<span class="params">farg, *args</span>):</span>     </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;args:&#x27;</span>, farg)     </span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> args:         </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;another arg:&#x27;</span>,value)<span class="comment">#可变长元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_var_kwargs</span>(<span class="params">farg, **kwargs</span>):</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;args:&#x27;</span>,farg)     </span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> kwargs:         </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;another keyword arg:%s:%s&#x27;</span> % (key, kwargs[key]) )<span class="comment">#可变长字典</span></span><br></pre></td></tr></table></figure><p>作用域的类型：</p><ol><li>局部作用域在函数内部定义，拥有一个局部作用域，局部变量只能在其被声明的函数内部访问。</li><li>嵌套作用域在函数内部定义，它和局部作用域是相对的，它相对于更上层的函数而言也是属于局部作用域。主要是为了实现Python的闭包，而增加的实现。</li><li>全局作用域在函数外部定义，拥有全局作用域，全局变量可以在整个程序范围内访问。函数内部可以通过global强制定义全局变量，当函数调用时，全局变量生效。全局作用域的作用范围仅限于单个模块文件内。</li><li>内置作用域是系统内固定模块里定义的变量。</li></ol><h3 id="1、递归函数"><a href="#1、递归函数" class="headerlink" title="1、递归函数"></a>1、递归函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span>       </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;from foo&#x27;</span>)     </span><br><span class="line">bar() </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span>     </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;from bar&#x27;</span>)     </span><br><span class="line">foo() </span><br><span class="line">foo()  <span class="comment">#间接调用自己</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>     </span><br><span class="line"><span class="built_in">print</span>(‘newdream<span class="string">&#x27;)     </span></span><br><span class="line"><span class="string">func() </span></span><br><span class="line"><span class="string">func() #直接调用自己</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="7、模块和包"><a href="#7、模块和包" class="headerlink" title="7、模块和包"></a>7、模块和包</h2><h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1.模块"></a>1.模块</h3><p>在Python中，一个.py文件就称之为一个模块（Module）。即一个文件被看作一个独立的模块，一个模块也可以被看做是一个文件</p><ol><li>内置模块：如sys, os, subprocess, time, json 等等 使用代码查看：print(help(‘modules’))</li><li>自定义模块：自定义模块时要注意命名，不能和Python自带的模块名称冲突。例如，系统自带了sys模块，自己的模块就不可命名为sys.py，否则将无法导入系统自带的sys模块。</li><li>开源模块：公开的第三方模块，如<a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a> 。可以使用pip install 安装，类似于手机app应用市场或者是maven仓库</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moudle <span class="comment">#导入模块</span></span><br><span class="line"><span class="keyword">from</span> moudle <span class="keyword">import</span> name <span class="keyword">as</span> name1 <span class="comment">#导入指定模块更名为name1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">3</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep </span><br><span class="line">sleep(<span class="number">3</span>) </span><br></pre></td></tr></table></figure><p>import语句导入指定的模块时会执行3个步骤 </p><ol><li>找到模块文件：在模块搜索路径下搜索模块文件   程序的主目录 PYTHONPATH目录   标准链接库目录 </li><li>编译成字节码：文件导入时会编译，因此，顶层文件的.pyc字节码文件在内部使用后会被丢弃，只有被导入的文件才会留下.pyc文件 </li><li>导入import（或重载reload）时，Python会立即执行模块文件的顶层程序代码（不在函数内的代码），而位于函数主体内的代码直到函数被调用后才会执行，reload()用于重新加载模块。</li></ol><p><strong>备注：</strong></p><p>1、如果不想如第三点那样执行导入模块的代码，常用的解决方案是：在python模块中需要测试或者直接运行的代码前加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(__name__==<span class="string">&#x27;__main__&#x27;</span>):</span><br></pre></td></tr></table></figure><p>2、通过sys.path.append(path) 函数来导入自定义模块所在的目录</p><h3 id="2、Python包"><a href="#2、Python包" class="headerlink" title="2、Python包"></a>2、Python包</h3><p>包用于将一组模块归并到一个目录中，将有联系的模块组织在一起，可以有效避免模块名称冲突问题，让应用组织结构更加清晰。         </p><p>Python语法要求每个包内都必须有__init__.py文件, <strong>init</strong>.py 可包含python代码，但通常为空，仅用于扮演包初始化、替目录产生模块命名空间以及使用目录导入时实现from*行为的角色。Python在执行模块导入时可以指定模块的导入路径import pack1.pack2.mod1 如python应用程序目录结构</p><p><img src="../images/Python/py1.png" alt="py1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#apps是最顶层的包，a和b是它的子包，可以这样导入：</span></span><br><span class="line"><span class="keyword">from</span> apps.a <span class="keyword">import</span> test </span><br><span class="line">a=test.adds(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a) </span><br></pre></td></tr></table></figure><h2 id="8、文件操作"><a href="#8、文件操作" class="headerlink" title="8、文件操作"></a>8、文件操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mknod(<span class="string">&quot;test.txt&quot;</span>)    <span class="comment">#创建空文件</span></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>,w)   <span class="comment">#直接打开一个文件，如果文件不存在则创建文件</span></span><br></pre></td></tr></table></figure><p>关于open 模式：</p><p>w   以写方式打开，<br>a   以追加模式打开 (从 EOF 开始, 必要时创建新文件)<br>r+   以读写模式打开<br>w+   以读写模式打开 (参见 w )<br>a+   以读写模式打开 (参见 a )<br>rb   以二进制读模式打开<br>wb   以二进制写模式打开 (参见 w )<br>ab   以二进制追加模式打开 (参见 a )<br>rb+  以二进制读写模式打开 (参见 r+ )<br>wb+  以二进制读写模式打开 (参见 w+ )<br>ab+  以二进制读写模式打开 (参见 a+ )</p><h3 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fp.read([size])            <span class="comment">#size为读取的长度，以byte为单位</span></span><br><span class="line"></span><br><span class="line">fp.readline([size])        <span class="comment">#读一行，如果定义了size，有可能返回的只是一行的一部分</span></span><br><span class="line"></span><br><span class="line">fp.readlines([size])       <span class="comment">#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span></span><br><span class="line"></span><br><span class="line">fp.write(<span class="built_in">str</span>)              <span class="comment">#把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class="line"></span><br><span class="line">fp.writelines(seq)         <span class="comment">#把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</span></span><br><span class="line"></span><br><span class="line">fp.close()                 <span class="comment">#关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。  如果一个文件在关闭后还对其进行操作会产生ValueError</span></span><br><span class="line"></span><br><span class="line">fp.flush()                 <span class="comment">#把缓冲区的内容写入硬盘</span></span><br><span class="line"></span><br><span class="line">fp.tell()                  <span class="comment">#返回文件操作标记的当前位置，以文件的开头为原点</span></span><br><span class="line"></span><br><span class="line">fp.<span class="built_in">next</span>()                  <span class="comment">#返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。</span></span><br><span class="line"></span><br><span class="line">fp.seek(offset[,whence])   <span class="comment">#将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。</span></span><br><span class="line"></span><br><span class="line">fp.truncate([size])        <span class="comment">#把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。</span></span><br></pre></td></tr></table></figure><h3 id="2、目录操作"><a href="#2、目录操作" class="headerlink" title="2、目录操作"></a>2、目录操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(<span class="string">&quot;file&quot;</span>)                   <span class="comment">#创建目录</span></span><br><span class="line"><span class="comment">#复制文件：</span></span><br><span class="line">shutil.copyfile(<span class="string">&quot;oldfile&quot;</span>,<span class="string">&quot;newfile&quot;</span>)       <span class="comment">#oldfile和newfile都只能是文件</span></span><br><span class="line">shutil.copy(<span class="string">&quot;oldfile&quot;</span>,<span class="string">&quot;newfile&quot;</span>)           <span class="comment">#oldfile只能是文件夹，newfile可以是文件，也可以是目标目录</span></span><br><span class="line"><span class="comment">#复制文件夹：</span></span><br><span class="line">shutil.copytree(<span class="string">&quot;olddir&quot;</span>,<span class="string">&quot;newdir&quot;</span>)         <span class="comment">#olddir和newdir都只能是目录，且newdir必须不存在</span></span><br><span class="line"><span class="comment">#重命名文件（目录）</span></span><br><span class="line">os.rename(<span class="string">&quot;oldname&quot;</span>,<span class="string">&quot;newname&quot;</span>)       <span class="comment">#文件或目录都是使用这条命令</span></span><br><span class="line"><span class="comment">#移动文件（目录）</span></span><br><span class="line">shutil.move(<span class="string">&quot;oldpos&quot;</span>,<span class="string">&quot;newpos&quot;</span>)   </span><br><span class="line"><span class="comment">#删除文件</span></span><br><span class="line">os.remove(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">#删除目录</span></span><br><span class="line">os.rmdir(<span class="string">&quot;dir&quot;</span>)<span class="comment">#只能删除空目录</span></span><br><span class="line">shutil.rmtree(<span class="string">&quot;dir&quot;</span>)    <span class="comment">#空目录、有内容的目录都可以删</span></span><br><span class="line"><span class="comment">#转换目录</span></span><br><span class="line">os.chdir(<span class="string">&quot;path&quot;</span>)   <span class="comment">#换路径</span></span><br></pre></td></tr></table></figure><h3 id="3、如何将文件名拆分"><a href="#3、如何将文件名拆分" class="headerlink" title="3、如何将文件名拆分"></a>3、如何将文件名拆分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">files = os.listdir(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(files)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">    portion = os.path.splitext(filename)</span><br><span class="line">    <span class="keyword">if</span> portion[<span class="number">1</span>] == <span class="string">&quot;.png&quot;</span>:</span><br><span class="line">        newname = portion[<span class="number">0</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        os.rename(filename, newname) <span class="comment">#将.png后缀名的文件改成.jpg后缀名</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python学习笔记&quot;&gt;&lt;a href=&quot;#Python学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Python学习笔记&quot;&gt;&lt;/a&gt;Python学习笔记&lt;/h1&gt;&lt;h2 id=&quot;1、Python标识符规则&quot;&gt;&lt;a href=&quot;#1、Python</summary>
      
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Mysql</title>
    <link href="http://example.com/2021/08/09/Mysql/"/>
    <id>http://example.com/2021/08/09/Mysql/</id>
    <published>2021-08-09T12:29:07.000Z</published>
    <updated>2021-08-10T14:46:56.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql学习笔记"><a href="#Mysql学习笔记" class="headerlink" title="Mysql学习笔记"></a>Mysql学习笔记</h1><h3 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h3><p>1、查看Mysql服务实例支持的存储引擎</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>2、设置默认的存储引擎</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">default_storage_engine</span>=MyISAM;</span><br><span class="line"><span class="comment">#设置存储引擎为MyISAM，Mysql5.6的默认存储引擎为InooDB。该设置为临时设置。</span></span><br></pre></td></tr></table></figure><h3 id="二、数据库操作-Database"><a href="#二、数据库操作-Database" class="headerlink" title="二、数据库操作 (Database)"></a>二、数据库操作 (Database)</h3><p>1、创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名;#创建数据库</span><br><span class="line">例如:</span><br><span class="line">create database student;创建一个名字为student的数据库</span><br><span class="line">create database student DEFAULT CHARSET=&#x27;utf8&#x27;;#指定字符集，可以避免中文乱码问题</span><br></pre></td></tr></table></figure><p>2、显示数据库结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database 数据库名;#查看数据库的结构</span><br></pre></td></tr></table></figure><p>3、删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><h3 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h3><p>1、整形</p><p>2、小数类型(decimal,float 单精度4字节,double 双精度8字节)</p><p><strong>decimal(length,precision)</strong>  length表示最大位数，precision表示精度</p><p>3、字符类型char()定长字符串、varchar()可变长字符串、text文本类型</p><p>4、日期类型 </p><p>date 默认格式YYYY-MM-DD （引用的时候要加引号’2021-08-09’），</p><p>time 默认格式HH:ii:ss，</p><p>year</p><p><strong>datetime</strong>和timestamp YYYY-MM-DD HH-ii-ss日期与时间的混合数据类型</p><h3 id="四、数据库表-table"><a href="#四、数据库表-table" class="headerlink" title="四、数据库表 (table)"></a>四、数据库表 (table)</h3><p>注意：对表进行操作之前需要选择数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use 数据库名;</span><br></pre></td></tr></table></figure><p>1、创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Create table 表名(</span><br><span class="line">字段名1 数据类型,</span><br><span class="line">字段名2 数据类型,</span><br><span class="line">字段名3 数据类型);</span><br></pre></td></tr></table></figure><p>2、查看表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表明; # 查看表的结构，不显示表中数据</span><br></pre></td></tr></table></figure><p>3、查看表中数据信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名; #显示表中详细信息</span><br></pre></td></tr></table></figure><p>4、删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名; #删除表后，会删除结构定义文件，表的索引和表中数据</span><br></pre></td></tr></table></figure><p>5、表中字段操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名; #删除字段</span><br><span class="line">alter table 表名 add 新字段名 数据类型[约束条件][first/(after 旧字段名)];</span><br><span class="line">#添加新字段</span><br><span class="line">alter table 表名 change 旧字段名 新字段名 新数据类型; #修改字段名</span><br><span class="line">alter table 表名 modify 字段名 新数据类型; #修改数类型</span><br></pre></td></tr></table></figure><p>6、修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename table 旧表名 to 新表名;</span><br><span class="line">alter table 旧表名 rename 新表名; #两种操作等效</span><br></pre></td></tr></table></figure><p>7、数据插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段顺序)] values (值列表);#不写字段顺序，则按默认顺序插入数据</span><br><span class="line">例如: insert into student values (&#x27;01&#x27;,&#x27;28&#x27;,&#x27;白白&#x27;,&#x27;2000-01-01&#x27;,22);</span><br></pre></td></tr></table></figure><p>使用查询语句插入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段顺序)] select(字段顺序) from 源表 where 条件表达式;</span><br></pre></td></tr></table></figure><p>8、复制表结构和内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Create table 新表 select* from 旧表;#复制表结构</span><br><span class="line">Create table 新表 select* from 旧表 where 1=2;只复制表结构，不复制数据</span><br></pre></td></tr></table></figure><p>9、表记录的修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段名1=值,字段名2=值 [where 条件表达式];</span><br></pre></td></tr></table></figure><p>10、删除表记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件表达式];</span><br><span class="line">truncate [table]表名; #清空表记录;</span><br><span class="line">#区别：Delete不加WHERE条件是删除所有数据</span><br><span class="line">#Truncate不能够加WHERE条件</span><br><span class="line">#Delete可以加WHERE条件</span><br><span class="line">#Truncate会重置AUTO_INCREMENT</span><br><span class="line">#Delete可以进行回滚操作</span><br></pre></td></tr></table></figure><p>11、表记录的查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select 字段列表 [as]别名 from 表名 [where 条件表达式]; </span><br></pre></td></tr></table></figure><h3 id="五、查询语句"><a href="#五、查询语句" class="headerlink" title="五、查询语句"></a>五、查询语句</h3><p>1、表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表 from 数据源</span><br><span class="line">[where条件表达式]</span><br><span class="line">[group by 分组字段]</span><br><span class="line">[having条件表达式]</span><br><span class="line">[orderby排序字段[asc|desc]]; #order by 默认asc升序</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、limit关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table LIMIT [offset,]rows|rows;</span><br><span class="line">#如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，</span><br><span class="line">#第二个参数指定返回记录行的最大数目。初始记录行的偏移量是0(而不是1),参数必须是整数;</span><br><span class="line">SELECT * FROM table LIMIT 0,10;#第0行开始，共返回10行记录</span><br><span class="line">SELECT * FROM table LIMIT 99,18446744073709551615;</span><br><span class="line">#第100行开始到最后1行(一个很大的值)</span><br><span class="line">SELECT * FROM table LIMIT 5;#返回前5行记录</span><br></pre></td></tr></table></figure><p>3、distinct关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select distinct 字段名 from 表名;</span><br></pre></td></tr></table></figure><p>4、带条件的查询</p><table><thead><tr><th>查询条件</th><th>符号</th></tr></thead><tbody><tr><td>比较</td><td>=、&lt;、&lt;=、&gt;=、!=、&lt;&gt;、&lt;=&gt;</td></tr><tr><td>指定范围</td><td>BETWEEN AND、NOT BETWEEN AND</td></tr><tr><td>匹配字符</td><td>LIKE 、NOT LIKE、IN、NOT IN</td></tr><tr><td>是否为空</td><td>IS NULL 、IS NOT NULL</td></tr><tr><td>多个查询条件</td><td>AND、OR</td></tr></tbody></table><h3 id="六、约束"><a href="#六、约束" class="headerlink" title="六、约束"></a>六、约束</h3><p>1、常见的约束条件</p><p>主键（primary key）</p><p>约束外键（Foreign Key）</p><p>约束唯一性（Unique）</p><p>约束默认值（Default）</p><p>约束非空（NOT NULL）</p><p>约束检查（Check）约束  # MYSQL不支持check约束，写了没有作用，但不会报错</p><p>2、非空约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t_user (</span><br><span class="line">id int(10),</span><br><span class="line">namevarchar(32) not null</span><br><span class="line">);#如果没有插入name字段数据，则会报错</span><br><span class="line">alter table t_user modify name varchar(32);#取消非空约束</span><br><span class="line">alter table t_user modify id int not null;#添加非空约束</span><br></pre></td></tr></table></figure><p>3、唯一性约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table test_unique(</span><br><span class="line">id int(10),</span><br><span class="line">name varchar(32) not null,</span><br><span class="line">email varchar(128) unique</span><br><span class="line">); #如果email字段重复插入，则会报错，但是该字段可以为nul</span><br><span class="line">alter table 表名 drop index 字段名;#删除唯一性约束</span><br><span class="line">alter table 表名 add unique(字段名);添加唯一性约束</span><br></pre></td></tr></table></figure><p>4、主键约束</p><p>主键不仅可以是一列，也可以由表中的两列或多列来共同标识。——复合主键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table test_primary(</span><br><span class="line">id int not null primary key,</span><br><span class="line">name varchar(50)</span><br><span class="line">);#设置id为主键</span><br><span class="line">create table test3_primary</span><br><span class="line">(id int not null,</span><br><span class="line">name varchar(50) not null,</span><br><span class="line">primary key(id,name)</span><br><span class="line">);#主键为id和name字段</span><br><span class="line">alter table 表名 drop primary key;#删除主键</span><br><span class="line">alter table 表名 add primary key(字段名);#添加主键</span><br></pre></td></tr></table></figure><p>5、默认值约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table test1_default(</span><br><span class="line">id int not null,</span><br><span class="line">name varchar(50) DEFAULT&#x27;abc&#x27;</span><br><span class="line">);#插入数据的时候，如果不写入name的值，则默认显示填入abc</span><br><span class="line">create table auto_test(</span><br><span class="line">id int not null auto_increment primary key,</span><br><span class="line">name varchar(25)</span><br><span class="line">);#创建表auto_test设置id的值为自增长</span><br><span class="line">ALTER TABLE 表名 ALTER 列名 DROP DEFAULT;#删除默认值约束</span><br><span class="line">ALTER TABLE 表名 ALTER 列名 SET DEFAULT &#x27;默认值&#x27;;#添加默认值约束</span><br></pre></td></tr></table></figure><h3 id="七、常见函数"><a href="#七、常见函数" class="headerlink" title="七、常见函数"></a>七、常见函数</h3><p>1、常用函数</p><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>MAX()</td><td>计算列的最大值</td></tr><tr><td>MIN()</td><td>计算列的最小值</td></tr><tr><td>Count()</td><td>统计行数</td></tr><tr><td>Sum()</td><td>获取单个列的合计值</td></tr><tr><td>Avg()</td><td>计算某个列的平均值</td></tr><tr><td>group_conca()</td><td>将多行字符串变成一行</td></tr><tr><td>replace(‘a’,’b’)</td><td>将字符串中的a替换成b</td></tr><tr><td>CURTIME()或CURRENT_TIME</td><td>返回当前日期</td></tr><tr><td>DATE_ADD与DATE_SUB</td><td>加上多少日期与减去多少日期  例如select date_add(“2016-12-31 23:59:59”,interval 1day);</td></tr></tbody></table><p>2、分组查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  sex,AVG(age) AS 平均年龄 FROM users</span><br><span class="line">GROUP BY sex;#统计每个性别的平均年龄</span><br></pre></td></tr></table></figure><p>3、Having关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT province,sex,COUNT(cname) FROM users </span><br><span class="line">GROUP BY province,sex</span><br><span class="line">HAVING COUNT(cname)&gt;3;</span><br><span class="line">#查询每一个省份男女生的人数，同时只需要显示人数数量超过3人的记录,having后面加聚合函数条件</span><br></pre></td></tr></table></figure><h3 id="八、高级查询"><a href="#八、高级查询" class="headerlink" title="八、高级查询"></a>八、高级查询</h3><p>1、内连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#等值连接3种连接方式</span><br><span class="line">select * from emp,dept where Dept_id=dept.id;</span><br><span class="line">#使用连接符 = </span><br><span class="line">select * from emp join dept on Dept_id=dept.id;</span><br><span class="line">#使用join .. on..</span><br><span class="line">select * from emp inner join dept onDept_id=dept.id;</span><br><span class="line">#使用innerjoin .. on..</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select e.ename as &#x27;姓名&#x27;,s.id as &#x27;等级&#x27; from enginfoe,salgrade s </span><br><span class="line">where e.sal BETWEEN s.local and s.maxline;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#自身连接：一个表与其自己进行连接</span><br><span class="line">SELECT  Qir.cno,Qir.cname, Qir.cpno,sec.cname FROM course Qir,course sec WHERE Qir.cpno=sec.cno;#查询每门课程的先修课名称</span><br></pre></td></tr></table></figure><p>2、外连接(左、右连接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.sno,sname,sex,age,dept,cno,grade FROM student s LEFT OUT JOIN sc ON s.sno=sc.sno;</span><br><span class="line">#左连接，如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。右连接与左连接相反</span><br></pre></td></tr></table></figure><p>3、主外键关系</p><p>1.两张表必须都是InnoDB表，并且它们没有临时表。</p><p>2.建立外键关系的对应列必须具有相似的InnoDB内部数据类型</p><p>3.建立外键关系的对应列必须建立了索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">create table stuInfo(</span><br><span class="line">Scodeint primary key,-- 学生的学号</span><br><span class="line">Sname char(10),-- 学生的姓名</span><br><span class="line">Saddress varchar(50),-- 学生的住址</span><br><span class="line">Sgrade int,-- 学生所在班级</span><br><span class="line">Semail varchar(50),-- 学生的邮箱地址</span><br><span class="line">Sbrith date); </span><br><span class="line"></span><br><span class="line">create table score(</span><br><span class="line">studentID int,</span><br><span class="line">coureseID int,</span><br><span class="line">score int,</span><br><span class="line">scoreID int primary key,</span><br><span class="line">foreign key(studentID) references stuInfo(Scode)#添加外键</span><br><span class="line">);</span><br><span class="line">alter table 表名称 drop foreign key 外键名称;#删除外键</span><br><span class="line">alter table 表名称 add foreign key (列名称)  references 关联表名称(列名称);#添加外键</span><br></pre></td></tr></table></figure><p>4、子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM article WHERE uid=(SELECT uid FROM user WHERE status=1 ORDER BY uid DESC LIMIT 1)#子查询允许把一个查询嵌套在另一个查询当中。</span><br></pre></td></tr></table></figure><p>5、派生表</p><p>在子查询返回的值中，也可能返回一个表，如果将子查询返回的虚拟表再次作为FROM子句的输入时，这就子查询的虚拟表就成为了一个派生表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name,t2.sex,a.city,a.age FROM t1,(SELECT city, MAX(age) FROM t2 GROUP BY city)a WHERE t1.age=t2.age;#将查询当作一个表</span><br></pre></td></tr></table></figure><p>6、联合查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cname,sex FROM users </span><br><span class="line">UNION      </span><br><span class="line">SELECT name,sex FROMteacher;#筛选掉相同的结果</span><br><span class="line"></span><br><span class="line">SELECT cname,sex FROM users </span><br><span class="line">UNION  ALL    </span><br><span class="line">SELECT name,sex FROM teacher;#保留相同项</span><br></pre></td></tr></table></figure><h3 id="九、索引和视图"><a href="#九、索引和视图" class="headerlink" title="九、索引和视图"></a>九、索引和视图</h3><p>1、创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名1 数据类型[约束条件],</span><br><span class="line">... [其他约束条件],</span><br><span class="line">... [ unique | fulltext ]  index  [索引名] ( 字段名[(长度)]  [ asc | desc ] ) </span><br><span class="line">) engine=存储引擎类型 default charset=字符集类型 #建表时添加索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create [ unique | fulltext ] index 索引名 on 表名( 字段名[(长度)]  [ asc | desc ] );</span><br><span class="line">alter table 表名add [ unique | fulltext ] index 索引名( 字段名[(长度)]  [ asc | desc ] );</span><br><span class="line">#建表后添加索引</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select studentid,score from score use index(index_stuid)  where studentid&gt;=3;#使用索引</span><br><span class="line">drop index 索引名 on 表名;#删除索引</span><br></pre></td></tr></table></figure><p>2、视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名[ (视图字段列表) ] as select语句;#创建视图</span><br><span class="line">drop view 视图名;#删除视图</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql学习笔记&quot;&gt;&lt;a href=&quot;#Mysql学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Mysql学习笔记&quot;&gt;&lt;/a&gt;Mysql学习笔记&lt;/h1&gt;&lt;h3 id=&quot;一、存储引擎&quot;&gt;&lt;a href=&quot;#一、存储引擎&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Mysql" scheme="http://example.com/categories/Mysql/"/>
    
    
    <category term="学习笔记" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>花海</title>
    <link href="http://example.com/2021/07/26/%E8%8A%B1%E6%B5%B7/"/>
    <id>http://example.com/2021/07/26/%E8%8A%B1%E6%B5%B7/</id>
    <published>2021-07-26T12:00:14.000Z</published>
    <updated>2021-08-19T01:25:15.836Z</updated>
    
    <content type="html"><![CDATA[<p>静止了，所有的花开<br>遥远了，清晰了爱</p><p>天郁闷，爱却更喜欢</p><p>那时候，我不懂</p><p>这叫爱，你喜欢</p><p>站在那窗台，你好久</p><p>都没再来，彩色的</p><p>时间染上空白，是你流的泪晕开</p><p>不要你离开，距离隔不开</p><p>思念变成海，在窗外进不来</p><p>原谅说太快，爱成了阻碍</p><p>手中的风筝放太快，回不来</p><p>不要你离开，回忆划不开</p><p>欠你的宠爱，我在等待重来</p><p>天空仍灿烂，它爱着大海</p><p>情歌被打败，爱已不存在</p><p>你喜欢，站在那窗台</p><p>你好久，都没再来</p><p>彩色的，时间染上空白</p><p>是你流的泪晕开，不要你离开</p><p>距离隔不开，思念变成海</p><p>在窗外进不来，原谅说太快</p><p>爱成了阻碍，手中的风筝放太快</p><p>回不来，不要你离开</p><p>回忆划不开，欠你的宠爱</p><p>我在等待重来，天空仍灿烂</p><p>它爱着大海，情歌被打败</p><p>爱已不存在</p>]]></content>
    
    
    <summary type="html">花海歌词</summary>
    
    
    
    
    <category term="-JayChou" scheme="http://example.com/tags/JayChou/"/>
    
  </entry>
  
</feed>
